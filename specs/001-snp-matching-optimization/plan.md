# Implementation Plan: SNP File Matching Optimization

**Branch**: `001-snp-matching-optimization` | **Date**: 2025-11-26 | **Spec**: [SNP Matching Optimization](spec.md)

**Input**: Feature specification with 5 user stories (3 P1, 2 P2), 10 functional requirements, 7 success criteria, 4 clarifications (grid search, manual port selection, flexible topology, frequency validation)

**Note**: This plan is generated by `/speckit.plan` command. See `.specify/templates/commands/plan.md` for execution workflow.

## Summary

**Core Value**: RF engineers can load vendor component design kits (.s2p files from Murata, TDK), automatically optimize impedance matching networks using grid search to reach Smith Chart center (50Ω with minimum line circle) across frequency range, and export validated designs—all in a user-friendly Python GUI.

**MVP Scope (3 P1 Stories)**:
1. Load & visualize main device .snp files (S1P/S2P/S3P/S4P with manual port selection)
2. Import & catalog vendor component libraries (.s2p files)
3. Automatic matching optimization using grid search (flexible topology: L-section, Pi-section, T-section)

**Enhancements (2 P2 Stories)**:
4. Interactive Smith Chart GUI with frequency overlay
5. Multi-frequency bandwidth optimization

## Technical Context

**Language/Version**: Python 3.9+ (per constitution)  
**Primary Dependencies**: 
  - `scikit-rf` (S-parameter file parsing, ABCD matrix operations, S-matrix cascading)
  - `matplotlib` + `numpy` (Smith Chart visualization, complex number math)
  - `PyQt6` (GUI framework, cross-platform desktop app)
  - `pytest` (test framework, per constitution)

**Storage**: File-based (no database needed for MVP; component library cached as JSON index)  
**Testing**: pytest + unittest for unit tests; integration tests for S-parameter cascading  
**Target Platform**: Linux/macOS/Windows (Python cross-platform)  
**Project Type**: Single desktop application (not web, not mobile)  
**Performance Goals**: 
  - Load .snp file: < 2 sec
  - Search 50+ components: < 1 sec per query
  - Single-freq optimize: < 5 sec
  - Multi-freq optimize: < 30 sec

**Constraints**: 
  - Passive matching only (no active devices)
  - 1–3 component networks (per spec)
  - 50Ω target impedance (RF standard, per spec assumptions)
  - No extrapolation (reject components with frequency gaps, per Q4 clarification)

**Scale/Scope**: 
  - MVP single-frequency matching with flexible topologies
  - Estimated 1500–2000 lines of code (parsing + GUI + optimizer + visualization)
  - Component library: up to 100 vendor components (typical design kit size)
  - Frequency points: typically 100–1000 points per .snp file

## Constitution Check

**Status**: ✅ COMPLIANT (No violations)

Validation against 5 core principles:

1. ✅ **I. Pythonic & Pragmatic**
   - Justification: Grid search algorithm chosen (brute-force, simple, deterministic) over genetic algorithms or convex optimization (YAGNI principle)
   - File I/O via `scikit-rf` (standard library for RF work)
   - Minimal dependencies justified: `scikit-rf` (essential for S-parameters), `matplotlib` (standard RF visualization), `PyQt6` (GUI framework, mature)

2. ✅ **II. Test-Driven Development (NON-NEGOTIABLE)**
   - TDD enforced in Phase 2 (Implementation tasks will define tests first)
   - Unit tests: Touchstone parser, S-matrix cascade, grid search optimizer, Smith Chart impedance conversion
   - Integration tests: End-to-end matching optimization (load → optimize → validate)
   - No code merged without passing tests (enforced in review gates)

3. ✅ **III. Independently Testable Features**
   - Story 1 (Load file): Testable without Stories 2–5 (CLI tool can display .snp data)
   - Story 2 (Library import): Testable without Stories 3–5 (CLI tool can search components)
   - Story 3 (Optimize): Testable without Stories 4–5 (CLI output of optimized components)
   - GUI (Stories 4–5) layered on top (can be tested separately with mock data)

4. ✅ **IV. Minimal Viable Product (MVP) Focus**
   - MVP scope tightly bounded to 3 P1 stories
   - Grid search chosen over more complex algorithms (MVP-aligned)
   - Manual port selection (simple, clear) vs. auto-detection heuristics (overengineered)
   - CLI-first approach (simpler than GUI-first), GUI added in Phase 2 enhancement

5. ✅ **V. Observability & Debuggability**
   - CLI output: structured text + JSON formats (for parsing and human readability)
   - S-parameter file I/O logged (frequency count, port count, impedance checks)
   - Optimization algorithm: log each grid search step (component combo, reflection achieved, selected components)
   - Error messages: include context (not just "Error"; include file path, frequency range, missing data)
   - Smith Chart: real-time frequency cursor (visual debuggability)

**Gate Status**: ✅ PASS (all principles verified; no violations)

**Re-Check Schedule**: After Phase 1 design completion, verify data model and API contracts align with principles.

## Project Structure

### Documentation (this feature)

```text
specs/001-snp-matching-optimization/
├── spec.md                          # Specification (this file's input)
├── plan.md                          # This file (implementation plan)
├── research.md                      # Phase 0 output (technology research)
├── data-model.md                    # Phase 1 output (entities, validation)
├── quickstart.md                    # Phase 1 output (API overview)
├── contracts/                       # Phase 1 output (API schemas)
│   ├── touchstone-parser.md        # Parser interface spec
│   ├── component-library.md        # Component search/catalog interface
│   ├── grid-optimizer.md           # Optimizer interface spec
│   └── smith-chart.md              # Visualization interface spec
└── tasks.md                         # Phase 2 output (implementation tasks)
```

### Source Code (repository root)

```text
src/
├── snp_tool/
│   ├── __init__.py                 # Package root
│   ├── main.py                     # CLI entry point
│   ├── parsers/
│   │   ├── __init__.py
│   │   ├── touchstone.py           # .snp/.s2p Touchstone parser (scikit-rf wrapper)
│   │   └── component_library.py    # Component .s2p parser + metadata extraction
│   ├── models/
│   │   ├── __init__.py
│   │   ├── snp_file.py             # SNP File entity (frequency, S-matrix, impedance)
│   │   ├── component.py            # Component Model entity (S2P, metadata, frequency_grid)
│   │   ├── matching_network.py     # Matching Network entity (components, topology, S-params)
│   │   └── optimization_result.py  # Optimization Result entity (solution, metrics)
│   ├── optimizer/
│   │   ├── __init__.py
│   │   ├── grid_search.py          # Grid search implementation (brute-force enumeration)
│   │   ├── cascader.py             # S-parameter cascade using ABCD matrices
│   │   └── metrics.py              # Reflection coefficient, VSWR, return loss calculation
│   ├── visualization/
│   │   ├── __init__.py
│   │   ├── smith_chart.py          # Smith Chart rendering (matplotlib)
│   │   ├── impedance_plot.py       # Impedance trajectory plotting
│   │   └── comparison.py           # Before/after comparison visualization
│   ├── gui/
│   │   ├── __init__.py
│   │   ├── app.py                  # PyQt6 main application
│   │   ├── windows/
│   │   │   ├── __init__.py
│   │   │   ├── main_window.py      # Main application window
│   │   │   ├── port_selector.py    # Port selection dialog (for S3P/S4P)
│   │   │   ├── topology_selector.py # Topology selection (L/Pi/T-section)
│   │   │   └── results_window.py   # Results display + export
│   │   └── widgets/
│   │       ├── __init__.py
│   │       ├── smith_chart_widget.py # Smith Chart display (matplotlib embedded)
│   │       ├── component_browser.py  # Component library search/filter
│   │       └── status_bar.py        # Status & progress display
│   └── utils/
│       ├── __init__.py
│       ├── logging.py              # Structured logging (console + JSON)
│       ├── exceptions.py           # Custom exception types
│       └── validators.py           # Frequency coverage, component validation

tests/
├── unit/
│   ├── test_touchstone_parser.py   # Touchstone parsing tests
│   ├── test_component_parser.py    # Component metadata extraction tests
│   ├── test_grid_optimizer.py      # Grid search algorithm tests
│   ├── test_cascader.py            # S-parameter cascade tests
│   ├── test_metrics.py             # Reflection/VSWR/loss calculation tests
│   └── test_smith_chart.py         # Smith Chart conversion tests
├── integration/
│   ├── test_end_to_end.py          # Full workflow: load → optimize → export
│   ├── test_frequency_validation.py # Component frequency coverage validation
│   ├── test_topology_selection.py  # Different topology optimization tests
│   └── test_multi_port.py          # S3P/S4P port selection tests
├── fixtures/
│   ├── sample_device.s2p           # Test fixture: 2-port device
│   ├── sample_components/          # Test fixtures: vendor components
│   │   ├── cap_10pf.s2p
│   │   ├── cap_100pf.s2p
│   │   ├── ind_1nh.s2p
│   │   └── ind_10nh.s2p
│   └── expected_results.json       # Expected optimization outputs

docs/
├── ARCHITECTURE.md                 # High-level architecture overview
├── ALGORITHM.md                    # Grid search algorithm documentation
├── API.md                          # API reference (CLI + Python module)
└── EXAMPLES.md                     # Example usage (CLI, Python API)

pyproject.toml                      # Project config (dependencies, version, scripts)
Makefile                            # Build targets (test, lint, run, package)
```

**Structure Decision**: Single desktop application with modular architecture. CLI-first (testable without GUI), GUI layered on top. Supports both:
- **CLI mode**: `python -m snp_tool.main --load device.s2p --library components/ --optimize`
- **GUI mode**: `python -m snp_tool.gui` → PyQt6 desktop application

**Rationale**: 
- Single project: Minimizes complexity per constitution (IV. MVP)
- Modular structure: Each component independently testable (III. Independent Testability)
- CLI-first: Enables TDD without GUI complexity (II. TDD)
- GUI optional: P2 enhancement can be deferred (IV. MVP focus)

## Complexity Tracking

| Aspect | Scope | Justification |
|--------|-------|---------------|
| **Parsing** | Full Touchstone format (freq in Hz/GHz, S-params in dB/phase or linear/phase or real/imag) | Required by FR-001; `scikit-rf` handles edge cases |
| **Grid Search** | Brute-force enumeration (N choose k) × topology permutations | Q1 clarification: deterministic, fits performance targets, MVP-aligned |
| **Topology Flexibility** | 3 preset topologies (L/Pi/T-section) enumerated by grid search | Q3 clarification: enables best RF solution per device; ~2x search space manageable |
| **Port Selection** | Manual dialog for S3P/S4P (user specifies source/load pair) | Q2 clarification: matches RF engineer workflow, avoids heuristics |
| **Component Library** | File-based with JSON index cache (no database) | Minimizes dependencies per constitution (I. Pythonic); fits MVP |
| **S-Parameter Cascade** | ABCD matrix multiplication (standard RF method) | FR-004; well-tested in `scikit-rf` |
| **Smith Chart Rendering** | matplotlib-based (frequency color overlay, interactive cursor) | Standard RF visualization; matplotlib mature & cross-platform |
| **GUI** | PyQt6 (cross-platform, mature, Python-native) | P2 enhancement; deferred from MVP if needed |

**No Overengineering**: 
- ✅ Single algorithm (grid search, not genetic + convex hybrid)
- ✅ No ML/AI components (deterministic matching)
- ✅ No cloud/async (single-machine CLI/GUI)
- ✅ No custom parsers (rely on `scikit-rf`)
- ✅ No database (file-based JSON caching)

## Phase Breakdown

### Phase 0: Research (~ 2 days)

**Objective**: Resolve NEEDS CLARIFICATION items and validate technology choices.

**Outputs**: `research.md`

**Tasks**:
1. Validate `scikit-rf` API for Touchstone parsing and ABCD cascading
   - Test fixture: Parse sample .snp file, extract S-parameters, frequency grid
   - Test fixture: Cascade two .s2p files using ABCD matrices
2. Validate `matplotlib` for Smith Chart rendering
   - Test fixture: Plot complex impedance on normalized Smith Chart
   - Test fixture: Frequency color overlay (rainbow gradient)
3. Validate `PyQt6` for cross-platform GUI
   - Test fixture: Create window with embedded matplotlib chart
4. Research grid search complexity for component selection
   - Estimate: 100 components, 1–3 stages → max ~100K combinations (manageable for 5–30 sec budget)
5. Research Touchstone format variations (edge cases in frequency units, S-param formats)
   - Clarify: What formats must be supported? (dB/phase, linear/phase, real/imag)

**Gate**: All NEEDS CLARIFICATION resolved before Phase 1 begins.

### Phase 1: Design & Contracts (~ 3–4 days)

**Objective**: Define data models, API contracts, and component interfaces.

**Outputs**: `data-model.md`, `/contracts/`, `quickstart.md`

**Tasks**:
1. Design data entities (entities from spec)
   - SNP File: frequency array, S-matrix per frequency, source/load impedance, port mapping
   - Component Model: S2P file path, manufacturer, part number, type (cap/inductor), value, frequency_grid
   - Matching Network: component list (1–3), topology, cascaded S-parameters, schematic
   - Optimization Result: components, topology, reflection achieved, VSWR, return loss
2. Design parser contracts
   - Input: .snp or .s2p file path
   - Output: Parsed object with frequency, S-matrix, metadata
   - Validation: Reject invalid formats, frequency gaps (per Q4)
3. Design component library contracts
   - Input: folder path
   - Output: Indexed library (searchable by type, value, frequency range)
   - Validation: Frequency grid coverage (reject components with gaps)
4. Design optimizer contracts
   - Input: SNP file, component library, topology, frequency range
   - Output: Matching Network (components, S-parameters, metrics)
   - Algorithm: Grid search (enumerate all combinations, calculate reflection, return best)
5. Design visualization contracts
   - Input: SNP file, Matching Network
   - Output: Smith Chart plot (matplotlib figure)
   - Features: Frequency color overlay, interactive cursor, before/after overlay
6. GUI wireframes (P2 enhancement planning)
   - Port selection dialog (S3P/S4P support)
   - Topology selection dropdown (L/Pi/T-section)
   - Results display (Smith Chart + metrics)

**Gate**: All contracts approved before Phase 2 begins.

### Phase 2: Implementation (~ 5–7 days)

**Objective**: Implement MVP (3 P1 stories) with TDD.

**Outputs**: Runnable CLI tool + unit/integration tests + docs

**Key Milestones**:
1. **Week 1: Core Modules (TDD)**
   - Story 1: Touchstone parser + tests (1 day)
   - Story 2: Component library importer + tests (1 day)
   - Story 3 Part A: Grid search optimizer + tests (2 days)
   - Story 3 Part B: S-parameter cascade + tests (1 day)

2. **Week 2: Integration & Polish**
   - Integration tests: end-to-end matching (1 day)
   - Smith Chart visualization + tests (1 day)
   - CLI interface + error handling (1 day)
   - Documentation + examples (1 day)
   - Performance optimization + profiling (if needed)

3. **Week 3: GUI (P2, if time permits)**
   - PyQt6 main window + widgets (2 days)
   - Integration with parser/optimizer (1 day)
   - Testing (1 day)

**TDD Process** (per constitution II):
- For each function: Write failing test → Get approval → Implement → Refactor
- Target: 90%+ code coverage on new code (100% for optimization core)

**Test-First Examples**:
```python
# Test: Touchstone parser
def test_parse_s2p_dB_angle():
    """Load .s2p file in dB/angle format"""
    # Expected: 100 frequency points, 2×2 S-matrix
    # Expected: S11 at 2.4 GHz = -10 dB at 45°
    
# Test: Grid search optimizer
def test_grid_search_two_stage_L_section():
    """Optimize 2-component L-section matching"""
    # Given: Device impedance trajectory
    # When: Grid search over 10 capacitors × 10 inductors = 100 combinations
    # Then: Find combination with minimum reflection at center frequency
    
# Test: S-parameter cascade
def test_cascade_three_networks():
    """Cascade main device + 2 matching components"""
    # Given: Device .s2p, Component 1 .s2p, Component 2 .s2p (all 2-port)
    # When: Cascade using ABCD matrices
    # Then: Combined S-parameters match expected result (from QUCS simulator)
```

**Deliverables**:
- `src/snp_tool/` (parser, models, optimizer, visualization)
- `tests/` (unit + integration tests, fixtures)
- `pyproject.toml` (dependencies, version, CLI entry point)
- `README.md` (quick start guide)
- `docs/` (architecture, algorithm, examples)

**Performance Benchmarks** (validation against SC-003):
- Load .snp (100 freq points): < 100 ms
- Search 50 components: < 50 ms
- Grid search 10 caps × 10 inductors (single-freq): < 2 sec
- Grid search across 3 topologies: < 5 sec
- Multi-frequency (100 freq points, 10 freq bands): < 10 sec

## Timeline

| Phase | Task | Duration | Start | End | Status |
|-------|------|----------|-------|-----|--------|
| 0 | Research | 2 days | Day 1 | Day 2 | Planned |
| 1 | Design & Contracts | 3-4 days | Day 3 | Day 6 | Planned |
| 2 | Implementation MVP | 5-7 days | Day 7 | Day 13 | Planned |
| 2+ | GUI (P2) | 3-4 days | Day 14 | Day 17 | Optional |

**Critical Path**: Phase 0 (research) → Phase 1 (design) → Phase 2 (implementation)

## Success Criteria Mapping

| Success Criterion | How Achieved | Phase |
|------------------|-------------|-------|
| SC-001: Load < 2 sec | Touchstone parser with `scikit-rf` (optimized for speed) | P2 (Milestone 1) |
| SC-002: Search < 1 sec | JSON index cache of component metadata | P2 (Milestone 1) |
| SC-003: Optimize < 5–30 sec | Grid search algorithm + numpy vectorization | P2 (Milestone 1–2) |
| SC-004: 90% hit rate | Grid search guarantees optimal solution within topology; test against RF devices | P2 (Milestone 2) |
| SC-005: Smith Chart interactive | matplotlib embedded in PyQt6 with frequency cursor | P2 (Milestone 2) or P2+ (GUI) |
| SC-006: Export precision | ABCD cascade + numerical validation | P2 (Milestone 2) |
| SC-007: UX satisfaction | CLI intuitive workflow → GUI adds polish (P2) | P2 + P2+ |

## Known Risks & Mitigations

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|-----------|
| Touchstone format variations (edge cases) | Medium | Medium | Phase 0: Research all variations; use `scikit-rf` (battle-tested) |
| Grid search performance (too slow) | Low | High | Phase 0: Benchmark with 100 components; Phase 2: Profile + optimize |
| Frequency grid mismatch (components missing freqs) | Medium | Low | Phase 0: Define handling (Q4: reject + warn); Phase 2: Validation tests |
| Smith Chart rendering performance | Low | Medium | Phase 0: Benchmark matplotlib; Phase 2: Optimize if needed (caching, threading) |
| GUI complexity (scope creep) | Medium | Medium | Keep GUI in P2+ (optional); MVP is CLI-only |

## Next Steps

1. **Execute Phase 0**: Run research tasks, resolve technology questions
2. **Generate `research.md`**: Document findings and technology choices
3. **Proceed to Phase 1**: Design entities, contracts, and component interfaces
4. **Proceed to Phase 2**: Implement MVP with TDD (Phase 2 will generate `tasks.md` with detailed task breakdown)
