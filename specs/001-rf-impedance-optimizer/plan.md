# Implementation Plan: RF Impedance Matching Optimizer

**Branch**: `001-rf-impedance-optimizer` | **Date**: 2025-11-27 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-rf-impedance-optimizer/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Build a comprehensive RF impedance matching optimization tool that allows RF engineers to load S-parameter files (Touchstone SNP format), manually add matching components (capacitors/inductors in series/shunt/cascaded configurations), and automatically optimize impedance matching using multi-metric weighted optimization. The tool provides both CLI (for automation/scripting) and GUI (for interactive visualization with Smith charts and rectangular plots) interfaces sharing a common computation engine, with session persistence for iterative design workflows.

## Technical Context

**Language/Version**: Python 3.9+ (aligned with existing pyproject.toml requirements)
**Primary Dependencies**: 
- numpy>=1.21.0 (complex number math, matrix operations for S-parameter calculations)
- scikit-rf>=0.29.0 (RF/microwave engineering library for S-parameter manipulation, impedance calculations, network cascading)
- matplotlib>=3.5.0 (plotting Smith charts and rectangular plots)
- PyQt6>=6.4.0 (GUI framework for interactive design interface)
- scipy>=1.9.0 (optimization algorithms: differential_evolution for multi-metric weighted optimization)
- python-json-logger>=2.0.0 (structured JSON logging for observability and debugging)

**Storage**: File-based (SNP files as input, custom session format for save/load, exported SNP/config files)
**Testing**: pytest>=7.0.0 with pytest-cov for coverage, TDD mandatory per constitution
**Target Platform**: Cross-platform CLI/GUI (Linux, macOS, Windows)
**Project Type**: Dual-interface application (CLI + GUI) with shared core computation engine
**Performance Goals**: 
- SNP file load and analysis: <5 seconds for valid files
- Component addition with S-parameter recalculation: <1 second for up to 1000 frequency points
- Optimization completion: <30 seconds for single-port matching with up to 2 components
- Session save/load: <3 seconds

**Constraints**:
- Maximum 5 components per port (computational tractability)
- Support SNP files with up to 10,000 frequency points without degradation
- Real-time S-parameter updates (<1 second response for component changes)
- Accuracy: S-parameter export within 0.1 dB magnitude, 1 degree phase

**Scale/Scope**: 
- Support S1P through S4P files initially (1-4 port networks), extensible to S8P/S16P
- Standard component libraries: E12, E24, E96 series
- Optimization: Multi-metric weighted (return loss, VSWR, bandwidth, component count)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Pythonic & Pragmatic
- âœ… **PASS**: Leverages existing Python ecosystem (numpy, scikit-rf) for RF engineering
- âœ… **PASS**: Clear domain separation: parsers, models, optimizer, visualization, CLI, GUI
- âœ… **PASS**: Uses standard library and proven RF packages; minimal custom reinvention

### II. Test-Driven Development (NON-NEGOTIABLE)
- âœ… **PASS**: TDD mandatory per workflow; all features require unit tests before implementation
- âœ… **PASS**: pytest infrastructure already in place (pyproject.toml, tests/ structure)
- âœ… **PASS**: Red-Green-Refactor cycle enforced in workflow; approval gates on test intent

### III. Independently Testable Features
- âœ… **PASS**: 5 user stories (P1: Load/Analyze SNP, Add Components; P2: Auto-optimization; P3: Export, Sessions)
- âœ… **PASS**: Each story independently testable with explicit acceptance scenarios
- âœ… **PASS**: P1 features deliverable alone; manual component placement provides value without optimization

### IV. Minimal Viable Product (MVP) Focus
- âœ… **PASS**: Prioritized user stories (P1 = MVP, P2 = enhancement, P3 = workflow support)
- âœ… **PASS**: YAGNI applied: no speculative features beyond explicit requirements
- âœ… **PASS**: Tight scope: 1-4 port networks initially, standard matching topologies

### V. Observability & Debuggability
- âœ… **PASS**: CLI text I/O design (stdin/args â†’ stdout); JSON output planned for automation
- âœ… **PASS**: Structured logging via python-json-logger for optimization decisions and S-parameter calculations (research.md Decision 3)
- âœ… **PASS**: Detailed validation reports (FR-012) with line numbers for SNP parsing errors
- âœ… **PASS**: Error messages actionable: validation reports include suggested corrections

### Technical Constraints Compliance
- âœ… **PASS**: Python 3.9+ (pyproject.toml aligned)
- âœ… **PASS**: Type hints mandatory on public functions (mypy configured in pyproject.toml)
- âœ… **PASS**: PEP 8 enforcement via black and flake8 (dev dependencies configured)
- âœ… **PASS**: pytest testing framework with coverage tracking

### Development Workflow Compliance
- âœ… **PASS**: Planning phase complete (spec.md with user stories, acceptance scenarios)
- â³ **IN PROGRESS**: Design phase (this plan document); constitution check being performed
- ðŸ”„ **PENDING**: Implementation phase (TDD workflow to follow)
- ðŸ”„ **PENDING**: Testing phase (unit + integration tests per contract changes)

**GATE STATUS**: âœ… **PASS** (all clarifications resolved in research.md Phase 0)

**Justification for Deviations**: None - all principles aligned

## Project Structure

### Documentation (this feature)

```text
specs/[###-feature]/
â”œâ”€â”€ plan.md              # This file (/speckit.plan command output)
â”œâ”€â”€ research.md          # Phase 0 output (/speckit.plan command)
â”œâ”€â”€ data-model.md        # Phase 1 output (/speckit.plan command)
â”œâ”€â”€ quickstart.md        # Phase 1 output (/speckit.plan command)
â”œâ”€â”€ contracts/           # Phase 1 output (/speckit.plan command)
â””â”€â”€ tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

## Project Structure

### Documentation (this feature)

```text
specs/001-rf-impedance-optimizer/
â”œâ”€â”€ spec.md              # Feature specification (complete)
â”œâ”€â”€ plan.md              # This file (/speckit.plan command output)
â”œâ”€â”€ research.md          # Phase 0 output (optimization algorithms, logging strategy)
â”œâ”€â”€ data-model.md        # Phase 1 output (entities, relationships, state machines)
â”œâ”€â”€ quickstart.md        # Phase 1 output (getting started guide)
â”œâ”€â”€ contracts/           # Phase 1 output (API contracts for CLI/GUI interfaces)
â”‚   â”œâ”€â”€ cli-interface.md # CLI command structure and arguments
â”‚   â””â”€â”€ core-api.md      # Core computation engine API contracts
â”œâ”€â”€ checklists/          # Quality validation
â”‚   â””â”€â”€ requirements.md  # Requirements checklist (complete)
â””â”€â”€ tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
src/snp_tool/            # Main package (existing structure, expanded)
â”œâ”€â”€ __init__.py
â”œâ”€â”€ main.py              # CLI entry point (existing)
â”‚
â”œâ”€â”€ models/              # Domain models (Phase 1)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ network.py       # SParameterNetwork entity
â”‚   â”œâ”€â”€ component.py     # MatchingComponent entity (series/shunt/cascaded)
â”‚   â”œâ”€â”€ solution.py      # OptimizationSolution entity
â”‚   â”œâ”€â”€ session.py       # WorkSession entity (save/load state)
â”‚   â””â”€â”€ frequency.py     # FrequencyPoint entity
â”‚
â”œâ”€â”€ parsers/             # SNP file parsing (Phase 1, leverages scikit-rf)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ touchstone.py    # Touchstone SNP parser with validation
â”‚   â””â”€â”€ validator.py     # Detailed validation reports (FR-012)
â”‚
â”œâ”€â”€ core/                # Core computation engine (Phase 1)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ network_calc.py  # S-parameter recalculation with component cascading
â”‚   â”œâ”€â”€ impedance.py     # Impedance transformations, metrics (VSWR, return loss)
â”‚   â””â”€â”€ component_lib.py # E12/E24/E96 standard component libraries
â”‚
â”œâ”€â”€ optimizer/           # Optimization engine (Phase 2)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ engine.py        # Multi-metric weighted optimization
â”‚   â”œâ”€â”€ objectives.py    # Objective functions (return loss, VSWR, bandwidth, component count)
â”‚   â””â”€â”€ constraints.py   # Constraint handling (max 5 components, value ranges)
â”‚
â”œâ”€â”€ cli/                 # CLI interface (Phase 1)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ commands.py      # CLI command handlers (load, add-component, optimize, export, save, load)
â”‚   â””â”€â”€ output.py        # Output formatters (text, JSON)
â”‚
â”œâ”€â”€ gui/                 # GUI interface (Phase 2, PyQt6)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ app.py           # Main GUI application (existing entry point)
â”‚   â”œâ”€â”€ mainwindow.py    # Main window with plot area
â”‚   â”œâ”€â”€ widgets/         # Custom widgets
â”‚   â”‚   â”œâ”€â”€ network_view.py    # SNP file display
â”‚   â”‚   â”œâ”€â”€ component_panel.py # Component addition/editing panel
â”‚   â”‚   â””â”€â”€ optimizer_panel.py # Optimization settings panel
â”‚   â””â”€â”€ dialogs/         # Dialogs
â”‚       â”œâ”€â”€ preferences.py # Settings dialog
â”‚       â””â”€â”€ export.py      # Export configuration dialog
â”‚
â”œâ”€â”€ visualization/       # Plotting (Phase 1, matplotlib)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ smith_chart.py   # Smith chart plotting
â”‚   â”œâ”€â”€ rectangular.py   # Magnitude/phase vs frequency plots
â”‚   â””â”€â”€ metrics.py       # VSWR, return loss visualization
â”‚
â””â”€â”€ utils/               # Utilities
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ engineering.py   # Engineering notation parser (10pF, 2.2nH)
    â”œâ”€â”€ session_io.py    # Session file save/load
    â””â”€â”€ logging.py       # Structured logging for optimization decisions

tests/                   # Test suite (pytest)
â”œâ”€â”€ fixtures/            # Test data
â”‚   â”œâ”€â”€ snp_files/       # Valid/invalid SNP files for testing
â”‚   â””â”€â”€ sessions/        # Test session files
â”‚
â”œâ”€â”€ unit/                # Unit tests (per module)
â”‚   â”œâ”€â”€ test_models.py
â”‚   â”œâ”€â”€ test_parsers.py
â”‚   â”œâ”€â”€ test_core.py
â”‚   â”œâ”€â”€ test_optimizer.py
â”‚   â”œâ”€â”€ test_cli.py
â”‚   â”œâ”€â”€ test_gui.py      # GUI widget tests
â”‚   â””â”€â”€ test_utils.py
â”‚
â”œâ”€â”€ integration/         # Integration tests
â”‚   â”œâ”€â”€ test_cli_workflow.py      # End-to-end CLI workflows
â”‚   â”œâ”€â”€ test_gui_workflow.py      # End-to-end GUI workflows
â”‚   â””â”€â”€ test_session_roundtrip.py # Save/load session integrity
â”‚
â””â”€â”€ performance/         # Performance benchmarks
    â”œâ”€â”€ test_large_snp.py         # 10,000 frequency points
    â””â”€â”€ test_optimization_speed.py # 30-second optimization target
```

**Structure Decision**: Single project structure with dual interfaces (CLI + GUI). The existing `src/snp_tool/` layout is preserved and expanded. CLI and GUI packages both depend on shared `core/`, `models/`, and `parsers/` modules ensuring consistent computation results (FR-019). The architecture follows layered design:
1. **Core Layer**: Domain models, parsers, computation engine
2. **Business Logic Layer**: Optimizer, component libraries
3. **Interface Layer**: CLI and GUI (independent, pluggable)
4. **Utilities Layer**: Cross-cutting concerns (logging, I/O, engineering notation)

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |
| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |

**STATUS**: No violations requiring justification. All constitution principles aligned.

---

## Phase 0: Research & Technology Decisions

**Goal**: Resolve all NEEDS CLARIFICATION items from Technical Context and establish technology foundation.

### Research Tasks

1. **Optimization Algorithm Selection**
   - **Question**: Which optimization algorithm for multi-metric weighted impedance matching?
   - **Context**: Need to optimize weighted combination of return loss, VSWR, bandwidth, component count with constraints (max 5 components, standard values E12/E24/E96, physical realizability)
   - **Candidates**: scipy.optimize methods (differential_evolution, minimize with multiple objectives), genetic algorithms, particle swarm optimization
   - **Deliverable**: Recommendation with rationale in research.md

2. **Scipy Version and Integration**
   - **Question**: Confirm scipy version requirement and integration approach with scikit-rf
   - **Context**: Optimization engine depends on scipy; ensure compatibility with numpy>=1.21.0 and scikit-rf>=0.29.0
   - **Deliverable**: Dependency specification and version constraints in research.md

3. **Structured Logging Strategy**
   - **Question**: Define structured logging format for optimization decisions and S-parameter calculations
   - **Context**: Constitution requires observability/debuggability; need logs for debugging optimization convergence, S-parameter transformations
   - **Candidates**: Python logging with JSON formatter, structlog library, custom logging utilities
   - **Deliverable**: Logging architecture and format specification in research.md

4. **Smith Chart Library**
   - **Question**: Best approach for Smith chart visualization with matplotlib
   - **Context**: FR-015 requires Smith chart plots; matplotlib has smith chart capabilities through smithplot or custom implementation
   - **Candidates**: Use scikit-rf built-in plotting, matplotlib-smithchart library, custom matplotlib polar projection
   - **Deliverable**: Recommendation with code examples in research.md

5. **Session File Format**
   - **Question**: Define custom session file format (JSON, YAML, binary, custom)
   - **Context**: FR-020/FR-021 require session save/load with SNP file reference, components, settings
   - **Candidates**: JSON (human-readable, parseable), YAML (human-friendly), pickle (Python-specific), custom binary
   - **Deliverable**: Format specification with schema example in research.md

6. **Component Cascading Mathematics**
   - **Question**: S-parameter cascade calculation for series/shunt lumped elements
   - **Context**: FR-003/FR-004 require real-time S-parameter recalculation with cascaded components; need ABCD matrix approach or T-parameter conversion
   - **Candidates**: scikit-rf Network.cascade() method, custom ABCD matrix implementation, T-parameter conversion
   - **Deliverable**: Mathematical approach and implementation strategy in research.md

### Best Practices Research

7. **PyQt6 Architecture for Dual CLI/GUI**
   - **Question**: Best practices for shared core engine with independent CLI/GUI interfaces
   - **Context**: FR-019 requires identical computation results; GUI should not duplicate business logic
   - **Pattern**: Model-View-Controller or similar separation
   - **Deliverable**: Architecture pattern recommendation in research.md

8. **Engineering Notation Parsing**
   - **Question**: Robust parsing for engineering notation (10pF, 2.2nH, 100uH, 1.5MHz)
   - **Context**: FR-005 requires standard engineering notation support; need error handling for invalid inputs
   - **Libraries**: pint (unit handling), custom regex parser
   - **Deliverable**: Parser implementation approach in research.md

**Output File**: `specs/001-rf-impedance-optimizer/research.md`

**Acceptance**: All NEEDS CLARIFICATION items resolved with specific technology choices and rationale.

---

## Phase 1: Design & Contracts

**Prerequisites**: research.md complete with all technology decisions

### Data Model Design

**Input**: Key Entities from spec.md (S-Parameter Network, Matching Component, Optimization Solution, Frequency Point, Port Configuration, Work Session)

**Tasks**:
1. Extract entities and define data classes with type hints
2. Define relationships and cardinalities
3. Specify validation rules from functional requirements
4. Document state transitions for interactive workflows (component addition, optimization)

**Output File**: `specs/001-rf-impedance-optimizer/data-model.md`

**Content Structure**:
```markdown
# Data Model: RF Impedance Matching Optimizer

## Entities

### SParameterNetwork
- Fields: frequencies (array), s_parameters (complex matrix), port_count (int), impedance_normalization (float)
- Relationships: has many FrequencyPoint, has many PortConfiguration
- Validation: port_count matches S-parameter matrix dimensions, frequencies monotonically increasing
- State: loaded â†’ modified (components added) â†’ optimized

### MatchingComponent
- Fields: component_type (enum: capacitor/inductor), value (float), placement (enum: series/shunt), port_number (int)
- Relationships: belongs to PortConfiguration
- Validation: value > 0, port_number within network port_count, max 5 per port
- Constraints: Physical realizability (1pF-100uF for caps, 1nH-100mH for inductors)

### OptimizationSolution
- Fields: components (list[MatchingComponent]), metrics (dict: return_loss, vswr, bandwidth), score (float)
- Relationships: references SParameterNetwork
- Validation: metrics within expected ranges
- Ranking: by weighted score from multi-metric optimization

[Continue for all entities...]

## Relationships Diagram
[ASCII or Mermaid diagram showing entity relationships]

## State Machines
[State transitions for network modification, optimization workflow]
```

### API Contracts

**Input**: Functional requirements (FR-001 through FR-021), user stories

**Tasks**:
1. Design CLI command structure (load, add-component, optimize, export, save, load-session)
2. Design core computation engine API (parse_snp, add_component, calculate_metrics, optimize, export_snp)
3. Define input/output contracts with JSON schemas where applicable

**Output Files**: 
- `specs/001-rf-impedance-optimizer/contracts/cli-interface.md`
- `specs/001-rf-impedance-optimizer/contracts/core-api.md`

**CLI Contract Example**:
```markdown
# CLI Interface Contract

## Commands

### load
**Purpose**: Load S-parameter file (FR-001)
**Usage**: `snp-tool load <file.snp> [--format json|text]`
**Input**: 
- file.snp: Path to Touchstone SNP file
- format: Output format (default: text)
**Output**: 
- Success: Network summary (port count, frequency range, impedance points)
- Error: Validation report with line numbers (FR-012)
**Exit Codes**: 0 (success), 1 (file not found), 2 (validation error)

### add-component
**Purpose**: Add matching component to port (FR-003)
**Usage**: `snp-tool add-component --port <N> --type <cap|ind> --value <val> --placement <series|shunt>`
**Input**:
- port: Port number (1-based)
- type: Component type (capacitor or inductor)
- value: Component value in engineering notation (10pF, 2.2nH)
- placement: Series or shunt configuration
**Output**: Updated S-parameters and impedance metrics
**Constraints**: Max 5 components per port (FR-003)

[Continue for all commands...]
```

**Core API Contract Example**:
```markdown
# Core Computation Engine API

## Module: snp_tool.parsers.touchstone

### parse_snp(filepath: str) -> SParameterNetwork
**Purpose**: Parse Touchstone SNP file with validation (FR-001, FR-012)
**Input**: filepath (absolute or relative path)
**Returns**: SParameterNetwork object
**Raises**: 
- FileNotFoundError: file does not exist
- ValidationError: with detailed report (line numbers, suggested fixes)
**Performance**: <5 seconds for files up to 10,000 frequency points

## Module: snp_tool.core.network_calc

### add_component(network: SParameterNetwork, component: MatchingComponent) -> SParameterNetwork
**Purpose**: Cascade component and recalculate S-parameters (FR-004)
**Input**: 
- network: Current S-parameter network
- component: Component to add (with port, type, value, placement)
**Returns**: New SParameterNetwork with updated S-parameters
**Raises**: 
- ValueError: if component exceeds 5-per-port limit or invalid placement
**Performance**: <1 second for up to 1000 frequency points (FR-004 constraint)

[Continue for all core functions...]
```

### Quickstart Guide

**Purpose**: Getting started documentation for users

**Output File**: `specs/001-rf-impedance-optimizer/quickstart.md`

**Content**:
```markdown
# Quickstart Guide: RF Impedance Matching Optimizer

## Installation

```bash
pip install -e .[all]  # Install with GUI and dev dependencies
```

## CLI Usage

### 1. Load an S-parameter file
```bash
snp-tool load my_antenna.s2p
```

### 2. Add matching components
```bash
snp-tool add-component --port 1 --type cap --value 10pF --placement series
snp-tool add-component --port 1 --type ind --value 5nH --placement shunt
```

### 3. Run optimization
```bash
snp-tool optimize --port 1 --target-impedance 50 --weights "return_loss=0.7,bandwidth=0.2,component_count=0.1"
```

### 4. Export results
```bash
snp-tool export --output matched_network.s2p --config components.json
```

## GUI Usage

```bash
snp-tool-gui
```

1. File â†’ Open SNP File
2. Use Component Panel to add capacitors/inductors
3. View Smith Chart and rectangular plots update in real-time
4. Click "Optimize" to run automated matching
5. File â†’ Export to save results

[Continue with examples...]
```

### Agent Context Update

**Task**: Run agent context update script to add technology choices to AI assistant context

**Command**:
```bash
.specify/scripts/bash/update-agent-context.sh copilot
```

**Purpose**: Update `.github/copilot-instructions.md` (or equivalent agent file) with:
- Python 3.9+ type hints requirement
- scikit-rf for RF engineering
- PyQt6 for GUI
- TDD workflow with pytest
- Structured logging format from research.md

**Note**: Script preserves manual additions between markers; only adds new technology from this plan.

**Acceptance**: Agent context file updated, verified via git diff

---

## Phase 1 Outputs Summary

**Expected Deliverables**:
1. âœ… `research.md` - All technology decisions with rationale
2. âœ… `data-model.md` - Entities, relationships, state machines
3. âœ… `contracts/cli-interface.md` - CLI command contracts
4. âœ… `contracts/core-api.md` - Core computation API contracts
5. âœ… `quickstart.md` - Getting started guide
6. âœ… Agent context updated (copilot-instructions.md or equivalent)

**Gate for Phase 2**: 
- All Phase 1 deliverables complete
- No unresolved NEEDS CLARIFICATION
- Re-run Constitution Check (all gates still PASS)

---

## Phase 2: Task Decomposition

**NOT INCLUDED IN THIS PLAN**

Phase 2 task decomposition is performed by the `/speckit.tasks` command, which:
1. Loads this plan.md and data-model.md
2. Generates user-story-driven task breakdown in tasks.md
3. Creates TDD test scaffolding for each task

**To proceed to Phase 2**: Run `/speckit.tasks` after Phase 1 completion.

---

## Implementation Notes

### Priority Sequence (from spec.md user stories)

**P1 (MVP - Must Have)**:
1. User Story 1: Load and Analyze S-Parameter Files
   - Touchstone parser with validation
   - Impedance calculation and display
   - Support S1P, S2P, S4P formats

2. User Story 2: Add Matching Components to Ports
   - Component models (capacitor, inductor, series/shunt/cascaded)
   - S-parameter recalculation with component cascading
   - Real-time updates (<1 second for 1000 freq points)

**P2 (Enhancement - Should Have)**:
3. User Story 3: Automated Impedance Matching Optimization
   - Multi-metric weighted optimization
   - Dual-mode: ideal values and standard component series (E12/E24/E96)
   - Multiple solution ranking

**P3 (Workflow Support - Nice to Have)**:
4. User Story 4: Export Optimized Network
   - Export component configuration (JSON/YAML)
   - Export cascaded SNP file

5. User Story 5: Save and Resume Work Sessions
   - Custom session file format
   - Complete state preservation

### Risk Mitigation

**Risk 1**: Optimization algorithm convergence for complex multi-metric objectives
- **Mitigation**: Phase 0 research evaluates multiple algorithms; implement simplest first (single-metric), iterate to multi-metric
- **Fallback**: Manual component placement (P1) still provides value if optimization struggles

**Risk 2**: GUI performance with real-time plot updates
- **Mitigation**: Implement plot throttling/debouncing; test with performance benchmarks (10,000 freq points)
- **Fallback**: CLI always available for batch processing

**Risk 3**: Session file backward compatibility
- **Mitigation**: Version session file format; implement migration logic for future versions
- **Acceptance**: Edge case testing for version mismatches (spec.md edge cases)

### Testing Strategy

**Unit Tests** (TDD per constitution):
- Every function in models/, parsers/, core/, optimizer/, utils/
- Test fixtures: valid/invalid SNP files, edge cases from spec.md
- Coverage target: 100% on new code

**Integration Tests**:
- End-to-end CLI workflows (load â†’ add components â†’ optimize â†’ export)
- End-to-end GUI workflows (same flow via GUI)
- Session save/load roundtrip integrity

**Performance Tests**:
- Large SNP files (10,000 frequency points): load time, recalculation time
- Optimization speed benchmarks: 30-second target for single-port matching

**Contract Tests**:
- CLI interface adherence to contracts/cli-interface.md
- Core API adherence to contracts/core-api.md
- Ensures CLI and GUI produce identical results (FR-019)

---

## Success Metrics Alignment

**From spec.md Success Criteria**:

| Criteria | Implementation Strategy | Verification Method |
|----------|------------------------|---------------------|
| SC-001: Load SNP <5s | Leverage scikit-rf efficient parsing | Performance test |
| SC-002: Component add <1s for 1000 pts | Optimize S-parameter cascade calculations | Performance test |
| SC-003: 10 dB improvement in 90% cases | Validate optimization algorithm | Integration test suite |
| SC-004: Optimization <30s for 2 components | Algorithm selection in Phase 0 research | Performance benchmark |
| SC-005: Full workflow <5 min | End-to-end integration tests | Timed workflow tests |
| SC-006: 95% SNP file compatibility | Extensive test fixtures from network analyzers | Fixture-based tests |
| SC-007: Export accuracy 0.1dB/1deg | Numerical precision validation | Unit tests with tolerance |
| SC-008: 60% time reduction vs manual | User study (post-implementation) | Manual comparison |
| SC-009: 80% first-time success (GUI) | UX design iteration | User testing |
| SC-010: 10k freq points no degradation | Stress testing | Performance benchmark |
| SC-011: CLI batch processing | Scripting examples in quickstart.md | Integration tests |
| SC-012: Session save/load <3s | I/O optimization | Performance test |

---

## Appendix: Technology Stack Summary

**From Research Phase (confirmed in research.md)**:

| Category | Technology | Version | Rationale |
|----------|-----------|---------|-----------|
| Language | Python | 3.9+ | Existing project, rich RF ecosystem |
| RF Library | scikit-rf | >=0.29.0 | Industry-standard S-parameter manipulation |
| Numerics | NumPy | >=1.21.0 | Complex number math, matrix operations |
| Optimization | SciPy | >=1.9.0 | differential_evolution for multi-objective optimization |
| Plotting | Matplotlib | >=3.5.0 | Smith charts, rectangular plots |
| GUI | PyQt6 | >=6.4.0 | Cross-platform, mature Qt bindings |
| Testing | pytest | >=7.0.0 | TDD framework, coverage integration |
| Code Quality | black, flake8, mypy | Latest | PEP 8 compliance, type checking |
| Logging | python-json-logger | >=2.0.0 | Structured JSON logging for observability |

**Dependencies Justification**:
- **scikit-rf**: Eliminates need to reimplement complex S-parameter mathematics, Touchstone parsing, network cascading
- **NumPy**: Required by scikit-rf; foundational for all RF calculations
- **SciPy**: Optimization algorithms for automated impedance matching (scipy.optimize.differential_evolution selected in research.md)
- **Matplotlib**: Proven library for Smith charts and RF plots
- **PyQt6**: Modern, actively maintained GUI framework; cross-platform compatibility
- **python-json-logger**: Structured JSON logging for observability without additional complexity

---

## Conclusion

This implementation plan establishes:
1. âœ… Complete technical context (all clarifications resolved in research.md)
2. âœ… Constitution compliance verification (all gates PASS)
3. âœ… Clear project structure leveraging existing layout
4. âœ… Phase 0 research completed (research.md generated with 8 technology decisions)
5. âœ… Phase 1 design deliverables completed (data-model.md, contracts/, quickstart.md)
6. âœ… Alignment with spec.md user stories and success criteria

**Next Command**: Phase 2 tasks decomposition completed in `tasks.md` - Ready for implementation.
